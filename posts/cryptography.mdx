---
title: "The Beautiful Math Behind Encryption"
date: "2025-09-13"
publish: true
---

We use encryption all of the time and, as developers, libraries make it easy to implement. In fact, most of the time we don't even have to do anything, it's just invisibly already implemented in background. But that's not really satisfying for me. I like to know how things work - usually at a very granular level.

I've been to a few crytography meetups and have watched a few talks and it's always amazed me how the math _just_ works. I think most developers understand _how_ encryption works but I think very few developers understand _why_ it works. And even fewer understand the math that makes it work.

Cryptography is a broad field that includes many different types of encryption schemes. In this post, we’ll focus on Elliptic Curve Cryptography (ECC), specifically within the context of Asymmetric Encryption and the math that makes it work.

Let's dive in.

# Asymmetric Encryption 101

Just to make sure that we're on the same page, let's do a quick primer on asymmetric encryption.

Asymmetric encryption, or sometimes called Public Key Encryption, uses a pair of keys - a public key and a private key, to securely encrypt and decrypt data.

![asymmtric](/asymm.png)

What makes it powerful is that the keys are mathematically linked. So you can share the public key with anyone in the world (hence:"public") and they can use it to encrypt a message that only the private key can decrypt.

Many protocols such as TLS, SSH, Signal, WireGuard and others use asymmetric encyryption for authentication/key exchange before switching to symmetric encryption for data encryption. This hybrid approach is pretty common.

Elliptic curve cryptography (which we'll get to in a second, I promise!), is just one way of doing asymmetric encryption. There are other ways such as RSA, Kyber, and Finite-field Diffie-Hellman but ECC is quickly becoming the standard.

Okay, great, now onto the fun stuff.

# What is an Elliptic Curve?

An elliptic curve is a mathematical curve that is typically defined by a cubic equation such as:

$y^{2}=x^{3}+ax+b$

![ecc](/ecc.png)

In elliptic curve crytography, we work with elliptic curves which are **nonsingular** cubic curves with a point at infinity over a finite field . These non-singular cubic curves have a few pretty cool characteristics that make them very useful in crytography:

1. The curve never intersects with itself
2. The point at infinity acts like a zero and it allows us to add points on the curve together
3. Every point on the curve has an inverse
4. If points $P$, $Q$ are on the curve then $P + Q$ is on the curve as well. This enables scalar multiplication of points and ensures that we never leave the curve.
5. The curve must be **Associative** such that $(P+Q)+R = P+(Q+R)$. This lets us sum points without worrying about paranthesis and the order of the points.
6. The curve must support **Commutativity** meaning that $P+Q = Q+P$. This just makes the math easier.

We'll see why these features are critical for ECC to work is just a bit.

One last thing, I mentioned above that we work with elliptic curves over a finite field. What does this mean?

It means that the elliptic curves that we work with in practice look less like the image above and more like this:

![ecc](/eccbase.png)

This is a view of the elliptic curve $y^2 \equiv x^3 - x + 1$ but over $\mathbb{F}_{23}$. You can actually see that every point in the curve has an inverse in the graph if you were to draw a horizontal line at $y = 11$ like so.

![ecc](/eccbasepair.png)

For our purposes, we'll use the first picture because it's easier to show why the math works but just remember that in practice we define elliptic curves over finite fields so they look more like the second picture.

(If you're interested in reading more in depth about elliptic curves, [this is free book.](http://tomlr.free.fr/Math%E9matiques/Math%20Complete/Cryptography/Guide%20to%20Elliptic%20Curve%20Cryptography%20-%20D.%20Hankerson,%20A.%20Menezes,%20S.%20Vanstone.pdf))

# Beautiful Symmetry

In the section above, we showed how every point in an elliptic curve has an inverse point which means that every point can be reflected over the x-axis and will still be on the same curve. This creates symmetry which we can express as:

For every point $P = (x,y)$, the inverse is $-P=(x,-y\bmod p)$

**Quite note**: We use $-y\bmod p$, since in ECC all arithmetic happens in a finite field $\mathbb F_p$, and elements of $\mathbb F_p$ are integers modulo p.

This symmetry has a few very important features that make the math behind ECC work.

The first is that any non-vertical line meets the curve in at most three points (counting multiplicity)

![ecc](/3inters.png)

Above, we plot the elliptic curve $y^2=x^3-x+1$ and then line $y=-2.5x-2$. You can see that it only intersects at 3 different points.

We can also derive this mathematically. Substitute a line:

$y=mx+c$ into $y^2=x^3-x+1$ and you get: $(mx+c)^2=x^3-x+1$,

Which is a **cubic equation in $x$**. You can see that it has the same form as the elliptic curve equation above. A cubic has ≤ 3 real roots, so a non-vertical line hits the curve in **at most three** real $x$’s counting multiplicity.

The second is what we call the **chord-and-tangent** addition law.

The chord-and-tangent addition law says that if you plot two points on the curve: $P$ and $Q$, and then draw a line through them, they will intersect at $R$. We can then reflect $R$ across the x-axis to get its inverse (which we noted at the beginning of the section) and then state that $P+Q = -R$.

![ecc](/chord.png)

This also works where $P = Q$. Instead of the drawing a line to connect $P$ and $Q$, you can just take the tangent at $P$, and where that tangent line intersects with the curve, we can call $R$.

![ecc](/tangent.png)

Following the same math as above where we reflect $R$ over the x-axis, we get $2P = -R$.

Why is this important?

Reflecting the third intersection across the x-axis gives a closed addition with inverses and the point at infinity as identity. This makes the curve’s points an **abelian group**, which enables efficient scalar multiplication in the form: $Q = k \cdot G$, where $G$ is the standard base point (like $P$ in our example above), $k \in \{1,\dots,n-1\}$ is an integer scalar (mod $n$), and $Q$ is the resulting point on the curve.

# The Power of Abelian Groups

Now for the beauty of scalar multiplication in abelian groups on elliptic curves that makes this whole thing work.

We can pick an initial base point $G$ on the curve and then add it to itself $k$ times. This will give us the resulting point $Q$ on the curve. Since we're just doubling and adding points to itself, we can use constant-time formulas such as **Montegomery ladder (X25519)** or **Complete Edwards formulas(Ed25519)**, meaning this is really fast.

Let's look at an example to build the intuition.

![ecc](/3g.png)

Here’s the extended diagram showing **$G$**, **$2G$**, and **$3G$**:

- The **dashed chord** is the line through $G$ and $2G$.
- It hits the curve a **third** time at $R$.
- Reflect $R$ across the x-axis to get **$3G = -R$**.
- I extended the x-axis to capture $x=56$, where $3G$ lands.

[Download the image](sandbox:/mnt/data/ecc_G_3G_chord.png)

For this curve $y^2=x^3-x+1$ with $G=(0,1)$:

- $2G=\left(\tfrac{1}{4},-\tfrac{7}{8}\right)$
- $R=(56,-419)$
- $3G=(56,419)$

string together many of these scalar multiplication operations together and it's fast! In fact, we can perform them in constant-time.

The best part? It's nearly impossible to reverse. Even if you know the resulting point $Q$ and the base point $G$, finding the scalar $k$ is incredibly difficult. This is called the "Elliptic curve discrete logarithm problem".

But why? Isn't it just algebra?

## What the attacker wants (hard direction)

Given $G$ and $Q=kG$, recover $k$. This is the **elliptic-curve discrete logarithm problem (ECDLP)**.

### Why it’s hard (intuition + facts)

- **Not ordinary algebra.** The “$\cdot$” is _repeated group addition_, not field multiplication; there’s no division by $G$ or a usable “log” map you can compute.
- **Wrap-around & nonlinearity.** Operations are over $\mathbb F_p$ and in a subgroup of size $n$. Coordinates of $Q$ are messy rational functions of the bits of $k$; inverting that is not solving a linear equation.
- **Best known generic attacks are square-root time.**

  - **Baby-Step/Giant-Step:** $O(\sqrt{n})$ time _and_ memory.
  - **Pollard’s rho:** $O(\sqrt{n})$ time, tiny memory.
    For a 256-bit prime order $n$, $\sqrt{n}\approx 2^{128}$ steps — astronomically large.

- **No subexponential index-calculus for generic prime-field curves.** (Contrast: finite-field DLP and integer factoring _do_ have subexponential algorithms, which is why ECC achieves similar security with much smaller parameters.)

* **“$+$”** is the **group addition** between two **points** on the curve: e.g., $P+Q$.
* **“$\cdot$”** is **scalar multiplication**: repeating that addition $k$ times with the **same** point $G$.

So when you write:

$$
Q = k \cdot G,
$$

you’re saying “take $G$ and add it to itself $k$ times.” You don’t write another “$+$” after that; the **adding happens inside** the computation of $k\cdot G$.

### How the “adding” shows up

By definition:

$$
k\cdot G = \underbrace{G + G + \cdots + G}_{k \text{ times}}.
$$

In practice we don’t literally loop $k$ times. We use binary:

- Write $k = \sum_i b_i 2^i$ with bits $b_i\in\{0,1\}$.
- Then

  $$
  k\cdot G \;=\; \sum_i b_i \,\big(2^i G\big).
  $$

  That sum uses **point addition** $+$ and **doubling** $2P = P+P$.

### Tiny example (k = 13 = 1101₂)

- Precompute doublings:
  $G,\; 2G,\; 4G=2(2G),\; 8G=2(4G)$.
- Select the ones with bit $1$: $8G + 4G + 1G$.
- Add them (group $+$) to get $Q$.

### Pseudocode (double-and-add)

```txt
R := O           // identity point
S := G
for each bit b of k from LSB→MSB:
  if b == 1: R = R + S   // point addition
  S = 2S                 // point doubling
return R  // equals k·G
```

So: you **don’t** write “$Q = k\cdot G + \dots$”. The **only** formula you need at the top level is $Q = k\cdot G$. The **adds** are the internal group operations used to compute that scalar multiple efficiently.
